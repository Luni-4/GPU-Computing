<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Deep Neural Network for MNIST Handwriting Recognition: mlnn.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dnn_mnist-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Deep Neural Network for MNIST Handwriting Recognition
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Deep Neural Network for MNIST Handwriting Recognition</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlnn.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Neural network functionality for a multi-layer, convolutional neural network.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="mnist-utils_8h_source.html">util/mnist-utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="screen_8h_source.html">util/screen.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlnn_8h_source.html">mlnn.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a494da497b677da05f7a302152fafd248"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a494da497b677da05f7a302152fafd248">OUT_OF_RANGE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a494da497b677da05f7a302152fafd248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea9b074d771e7fc536af05f468c277c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aea9b074d771e7fc536af05f468c277c6">getLayerNodeCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:aea9b074d771e7fc536af05f468c277c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in a layer.  <a href="#aea9b074d771e7fc536af05f468c277c6">More...</a><br /></td></tr>
<tr class="separator:aea9b074d771e7fc536af05f468c277c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa794952814e98d37851b303e17c60ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aa794952814e98d37851b303e17c60ef6">getLayerColumnCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:aa794952814e98d37851b303e17c60ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in a layer.  <a href="#aa794952814e98d37851b303e17c60ef6">More...</a><br /></td></tr>
<tr class="separator:aa794952814e98d37851b303e17c60ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed146259dc505f7ef7b8f04881ee6fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a8ed146259dc505f7ef7b8f04881ee6fd">getNodeBackwardConnectionCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a8ed146259dc505f7ef7b8f04881ee6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of backward connections of a NODE (not of a layer)  <a href="#a8ed146259dc505f7ef7b8f04881ee6fd">More...</a><br /></td></tr>
<tr class="separator:a8ed146259dc505f7ef7b8f04881ee6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b86acbe777bfb0967fa143cd4409d00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a7b86acbe777bfb0967fa143cd4409d00">getNodeForwardConnectionCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a7b86acbe777bfb0967fa143cd4409d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of forward connections of a NODE (not of a layer)  <a href="#a7b86acbe777bfb0967fa143cd4409d00">More...</a><br /></td></tr>
<tr class="separator:a7b86acbe777bfb0967fa143cd4409d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec138a1288ed75be554026e0dd5fbf4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aec138a1288ed75be554026e0dd5fbf4e">getLayerWeightCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:aec138a1288ed75be554026e0dd5fbf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of weights for a layer (based on a given layer definition)  <a href="#aec138a1288ed75be554026e0dd5fbf4e">More...</a><br /></td></tr>
<tr class="separator:aec138a1288ed75be554026e0dd5fbf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbce462165eb8f47736c942765b3f38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a0cbce462165eb8f47736c942765b3f38">getColumnCount</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a0cbce462165eb8f47736c942765b3f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in a layer (based on a give layer definition)  <a href="#a0cbce462165eb8f47736c942765b3f38">More...</a><br /></td></tr>
<tr class="separator:a0cbce462165eb8f47736c942765b3f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c35bcf728651f05c3461d89a04144d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a0c35bcf728651f05c3461d89a04144d6">getLayerWeightBlockSize</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a0c35bcf728651f05c3461d89a04144d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory (byte) size of the weights block for a specific layer.  <a href="#a0c35bcf728651f05c3461d89a04144d6">More...</a><br /></td></tr>
<tr class="separator:a0c35bcf728651f05c3461d89a04144d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f53bda77b00d02e5ee244a5bf80d571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a6f53bda77b00d02e5ee244a5bf80d571">getNetworkWeightBlockSize</a> (int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:a6f53bda77b00d02e5ee244a5bf80d571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory size of the network's weights block based on a given array of layer definitions.  <a href="#a6f53bda77b00d02e5ee244a5bf80d571">More...</a><br /></td></tr>
<tr class="separator:a6f53bda77b00d02e5ee244a5bf80d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08566a3881abbe4047eb9329b08355a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a08566a3881abbe4047eb9329b08355a1">getNodeSize</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a08566a3881abbe4047eb9329b08355a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory (byte) size of a node based on a given layer definition.  <a href="#a08566a3881abbe4047eb9329b08355a1">More...</a><br /></td></tr>
<tr class="separator:a08566a3881abbe4047eb9329b08355a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6765283218ff82291d62935de17e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#af6d6765283218ff82291d62935de17e4">getColumnSize</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:af6d6765283218ff82291d62935de17e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory (byte) size of a column based on a given layer definition.  <a href="#af6d6765283218ff82291d62935de17e4">More...</a><br /></td></tr>
<tr class="separator:af6d6765283218ff82291d62935de17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793c21439d5b143c92b5aaa4ffc3f947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a793c21439d5b143c92b5aaa4ffc3f947">getLayerSize</a> (<a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDef)</td></tr>
<tr class="memdesc:a793c21439d5b143c92b5aaa4ffc3f947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory (byte) size of a specific layer based on a given layer definition.  <a href="#a793c21439d5b143c92b5aaa4ffc3f947">More...</a><br /></td></tr>
<tr class="separator:a793c21439d5b143c92b5aaa4ffc3f947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22291d5113dee2df10981d3ac398fda8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a22291d5113dee2df10981d3ac398fda8">getNetworkSize</a> (int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:a22291d5113dee2df10981d3ac398fda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory size of the network based on an array of layer definitions and weightBlockSize.  <a href="#a22291d5113dee2df10981d3ac398fda8">More...</a><br /></td></tr>
<tr class="separator:a22291d5113dee2df10981d3ac398fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71a3e5c9908ba6d1a5d4cbb9a1da62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ac71a3e5c9908ba6d1a5d4cbb9a1da62e">getColumnNode</a> (<a class="el" href="struct_column.html">Column</a> *column, int nodeId)</td></tr>
<tr class="memdesc:ac71a3e5c9908ba6d1a5d4cbb9a1da62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a specific node defined by its id from a given layer.  <a href="#ac71a3e5c9908ba6d1a5d4cbb9a1da62e">More...</a><br /></td></tr>
<tr class="separator:ac71a3e5c9908ba6d1a5d4cbb9a1da62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5338950c6985c0232440b529b05d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_column.html">Column</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a17a5338950c6985c0232440b529b05d9">getLayerColumn</a> (<a class="el" href="struct_layer.html">Layer</a> *layer, int columnId)</td></tr>
<tr class="memdesc:a17a5338950c6985c0232440b529b05d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a specific column defined by its id.  <a href="#a17a5338950c6985c0232440b529b05d9">More...</a><br /></td></tr>
<tr class="separator:a17a5338950c6985c0232440b529b05d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db7db0fe79bde079c77cdf70d66047d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a4db7db0fe79bde079c77cdf70d66047d">getNetworkNode</a> (<a class="el" href="struct_layer.html">Layer</a> *layer, int columnId, int nodeId)</td></tr>
<tr class="memdesc:a4db7db0fe79bde079c77cdf70d66047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a specific node defined by its layer, column and node id.  <a href="#a4db7db0fe79bde079c77cdf70d66047d">More...</a><br /></td></tr>
<tr class="separator:a4db7db0fe79bde079c77cdf70d66047d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c60aaa5ced3776b44d804530b96d684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a2c60aaa5ced3776b44d804530b96d684">getNetworkLayer</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId)</td></tr>
<tr class="memdesc:a2c60aaa5ced3776b44d804530b96d684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a specific layer defined by its id from the network.  <a href="#a2c60aaa5ced3776b44d804530b96d684">More...</a><br /></td></tr>
<tr class="separator:a2c60aaa5ced3776b44d804530b96d684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c96db47579c05ca68eb580627f075cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a6c96db47579c05ca68eb580627f075cf">getDerivative</a> (<a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> outVal, <a class="el" href="mlnn_8h.html#a56b0419d049f390f332329193f952b41">ActFctType</a> actType)</td></tr>
<tr class="memdesc:a6c96db47579c05ca68eb580627f075cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the given outputValue to the derivate of the activation function.  <a href="#a6c96db47579c05ca68eb580627f075cf">More...</a><br /></td></tr>
<tr class="separator:a6c96db47579c05ca68eb580627f075cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4140a0839a2ef1ba88b90ba340b41090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a4140a0839a2ef1ba88b90ba340b41090">updateNodeWeights</a> (<a class="el" href="struct_node.html">Node</a> *updateNode, double learningRate)</td></tr>
<tr class="memdesc:a4140a0839a2ef1ba88b90ba340b41090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a node's weights based on given learning rate.  <a href="#a4140a0839a2ef1ba88b90ba340b41090">More...</a><br /></td></tr>
<tr class="separator:a4140a0839a2ef1ba88b90ba340b41090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d895940d6ff9c2f4a0403ff2ccee3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a306d895940d6ff9c2f4a0403ff2ccee3">calcNodeError</a> (<a class="el" href="struct_node.html">Node</a> *thisNode)</td></tr>
<tr class="memdesc:a306d895940d6ff9c2f4a0403ff2ccee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total error of a node by adding up all the partial errors from the following layer.  <a href="#a306d895940d6ff9c2f4a0403ff2ccee3">More...</a><br /></td></tr>
<tr class="separator:a306d895940d6ff9c2f4a0403ff2ccee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0365337d14604a9997ef50adf40d1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a0e0365337d14604a9997ef50adf40d1e">backPropagateLayer</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId)</td></tr>
<tr class="memdesc:a0e0365337d14604a9997ef50adf40d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back propagates network error to hidden layer.  <a href="#a0e0365337d14604a9997ef50adf40d1e">More...</a><br /></td></tr>
<tr class="separator:a0e0365337d14604a9997ef50adf40d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83887b62ebfd3e1a850cf1a4af109cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a83887b62ebfd3e1a850cf1a4af109cd8">backPropagateOutputLayer</a> (<a class="el" href="struct_network.html">Network</a> *nn, int targetClassification)</td></tr>
<tr class="memdesc:a83887b62ebfd3e1a850cf1a4af109cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the error (difference of desired classification vs actual node output) of each output node and back propagates the error in the output layer to the previous layer.  <a href="#a83887b62ebfd3e1a850cf1a4af109cd8">More...</a><br /></td></tr>
<tr class="separator:a83887b62ebfd3e1a850cf1a4af109cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf50ce1c1d143d737a0e7e9fa7faac4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#acf50ce1c1d143d737a0e7e9fa7faac4f">backPropagateNetwork</a> (<a class="el" href="struct_network.html">Network</a> *nn, int targetClassification)</td></tr>
<tr class="memdesc:acf50ce1c1d143d737a0e7e9fa7faac4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backpropagates the output nodes' errors from output layer backwards to first layer.  <a href="#acf50ce1c1d143d737a0e7e9fa7faac4f">More...</a><br /></td></tr>
<tr class="separator:acf50ce1c1d143d737a0e7e9fa7faac4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8e1d7b9e01161fbe06cc9f08aafca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a5e8e1d7b9e01161fbe06cc9f08aafca1">activateNode</a> (<a class="el" href="struct_node.html">Node</a> *node, <a class="el" href="mlnn_8h.html#a56b0419d049f390f332329193f952b41">ActFctType</a> actType)</td></tr>
<tr class="memdesc:a5e8e1d7b9e01161fbe06cc9f08aafca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an activiation function to a specified node.  <a href="#a5e8e1d7b9e01161fbe06cc9f08aafca1">More...</a><br /></td></tr>
<tr class="separator:a5e8e1d7b9e01161fbe06cc9f08aafca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766a4329ca60f56b46872ac1ef641ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a766a4329ca60f56b46872ac1ef641ec5">calcNodeOutput</a> (<a class="el" href="struct_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a766a4329ca60f56b46872ac1ef641ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the output value of a specified node.  <a href="#a766a4329ca60f56b46872ac1ef641ec5">More...</a><br /></td></tr>
<tr class="separator:a766a4329ca60f56b46872ac1ef641ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057b6a28d523972c7a38b98302cad2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aa057b6a28d523972c7a38b98302cad2c">calcNetworkLayer</a> (<a class="el" href="struct_layer.html">Layer</a> *layer)</td></tr>
<tr class="memdesc:aa057b6a28d523972c7a38b98302cad2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the output values of all nodes of a given layer.  <a href="#aa057b6a28d523972c7a38b98302cad2c">More...</a><br /></td></tr>
<tr class="separator:aa057b6a28d523972c7a38b98302cad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aab148c4bc1bc374291e64edbf1e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ab3aab148c4bc1bc374291e64edbf1e2d">feedForwardNetwork</a> (<a class="el" href="struct_network.html">Network</a> *nn)</td></tr>
<tr class="memdesc:ab3aab148c4bc1bc374291e64edbf1e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feeds forward (=calculating a node's output value and applying an activation function) layer by layer.  <a href="#ab3aab148c4bc1bc374291e64edbf1e2d">More...</a><br /></td></tr>
<tr class="separator:ab3aab148c4bc1bc374291e64edbf1e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498c47a729c9e9a8e3996dc4cc01a257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a498c47a729c9e9a8e3996dc4cc01a257">feedInput</a> (<a class="el" href="struct_network.html">Network</a> *nn, <a class="el" href="struct_vector.html">Vector</a> *v)</td></tr>
<tr class="memdesc:a498c47a729c9e9a8e3996dc4cc01a257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feeds some <a class="el" href="struct_vector.html">Vector</a> data into the INPUT layer of the network.  <a href="#a498c47a729c9e9a8e3996dc4cc01a257">More...</a><br /></td></tr>
<tr class="separator:a498c47a729c9e9a8e3996dc4cc01a257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594878532b97d3e8581dcde4da0ffdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a2594878532b97d3e8581dcde4da0ffdd">getNetworkClassification</a> (<a class="el" href="struct_network.html">Network</a> *nn)</td></tr>
<tr class="memdesc:a2594878532b97d3e8581dcde4da0ffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network's classification of the input image by choosing the node with the hightest output.  <a href="#a2594878532b97d3e8581dcde4da0ffdd">More...</a><br /></td></tr>
<tr class="separator:a2594878532b97d3e8581dcde4da0ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a26cfa36bff4cdbcd279508a39b44b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a5a26cfa36bff4cdbcd279508a39b44b4">initNetworkWeights</a> (<a class="el" href="struct_network.html">Network</a> *nn)</td></tr>
<tr class="separator:a5a26cfa36bff4cdbcd279508a39b44b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d9688a88ad92eb0eda60f0c57f0db9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ab3d9688a88ad92eb0eda60f0c57f0db9">calcStride</a> (int tgtWidth, int filter, int srcWidth)</td></tr>
<tr class="memdesc:ab3d9688a88ad92eb0eda60f0c57f0db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the stride (number of nodes/columns that are skipped) in a convolutional kernel.  <a href="#ab3d9688a88ad92eb0eda60f0c57f0db9">More...</a><br /></td></tr>
<tr class="separator:ab3d9688a88ad92eb0eda60f0c57f0db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8067b0a998c5d56f43059af6ad93651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ac8067b0a998c5d56f43059af6ad93651">calcFilterColumnIds</a> (<a class="el" href="struct_layer.html">Layer</a> *srcLayer, int srcColId, <a class="el" href="struct_layer.html">Layer</a> *tgtLayer, <a class="el" href="struct_vector.html">Vector</a> *filterColIds)</td></tr>
<tr class="memdesc:ac8067b0a998c5d56f43059af6ad93651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of FILTER-many column ids representing a moving x*y kernel window in the target layer.  <a href="#ac8067b0a998c5d56f43059af6ad93651">More...</a><br /></td></tr>
<tr class="separator:ac8067b0a998c5d56f43059af6ad93651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb20b4438bf1c9594706fb000753b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#acfb20b4438bf1c9594706fb000753b71">initNetworkBackwardConnectionsConvNode</a> (<a class="el" href="struct_node.html">Node</a> *node, int srcLevel, <a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *srcLayerWeightPtr, <a class="el" href="struct_layer.html">Layer</a> *targetLayer, <a class="el" href="struct_vector.html">Vector</a> *filterColIds, <a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *nullWeight)</td></tr>
<tr class="memdesc:acfb20b4438bf1c9594706fb000753b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a single convolutional node by setting its connections weights pointers.  <a href="#acfb20b4438bf1c9594706fb000753b71">More...</a><br /></td></tr>
<tr class="separator:acfb20b4438bf1c9594706fb000753b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd605a32d4c375d73f72d0f23584b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a53fd605a32d4c375d73f72d0f23584b5">initNetworkBackwardConnectionsFCNode</a> (<a class="el" href="struct_node.html">Node</a> *thisNode, <a class="el" href="struct_layer.html">Layer</a> *prevLayer, <a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *nodeWeightPtr)</td></tr>
<tr class="memdesc:a53fd605a32d4c375d73f72d0f23584b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a node of a normal, fully connected node.  <a href="#a53fd605a32d4c375d73f72d0f23584b5">More...</a><br /></td></tr>
<tr class="separator:a53fd605a32d4c375d73f72d0f23584b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b1174c9c2a9c2deb35870af493210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a3c4b1174c9c2a9c2deb35870af493210">initNetworkForwardConnectionsAnyNode</a> (<a class="el" href="struct_node.html">Node</a> *thisNode, <a class="el" href="struct_layer.html">Layer</a> *nextLayer)</td></tr>
<tr class="separator:a3c4b1174c9c2a9c2deb35870af493210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94a8a48b0b4385887b3e0cf2d5eaa89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#af94a8a48b0b4385887b3e0cf2d5eaa89">initNetworkForwardConnections</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId)</td></tr>
<tr class="separator:af94a8a48b0b4385887b3e0cf2d5eaa89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1c0bc7a8f6fa060d9601f3eafc00de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vector.html">Vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aaf1c0bc7a8f6fa060d9601f3eafc00de">createFilterColumnIds</a> (<a class="el" href="struct_layer.html">Layer</a> *thisLayer, int columnId, <a class="el" href="struct_layer.html">Layer</a> *prevLayer)</td></tr>
<tr class="memdesc:aaf1c0bc7a8f6fa060d9601f3eafc00de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an array of FILTER-many column ids representing a moving x*y kernel window.  <a href="#aaf1c0bc7a8f6fa060d9601f3eafc00de">More...</a><br /></td></tr>
<tr class="separator:aaf1c0bc7a8f6fa060d9601f3eafc00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f1992d0aaec1e32c16f5100a7ca0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a12f1992d0aaec1e32c16f5100a7ca0c8">setNetworkNodeDefaults</a> (<a class="el" href="struct_layer.html">Layer</a> *thisLayer, <a class="el" href="struct_column.html">Column</a> *column, <a class="el" href="struct_node.html">Node</a> *node, <a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *nullWeight)</td></tr>
<tr class="memdesc:a12f1992d0aaec1e32c16f5100a7ca0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values for a node during its initialization.  <a href="#a12f1992d0aaec1e32c16f5100a7ca0c8">More...</a><br /></td></tr>
<tr class="separator:a12f1992d0aaec1e32c16f5100a7ca0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f85c53c92f9ca22d1e8a346e45caeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ab4f85c53c92f9ca22d1e8a346e45caeb">initNetworkNodes</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId, int columnId)</td></tr>
<tr class="memdesc:ab4f85c53c92f9ca22d1e8a346e45caeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the nodes in a given network column.  <a href="#ab4f85c53c92f9ca22d1e8a346e45caeb">More...</a><br /></td></tr>
<tr class="separator:ab4f85c53c92f9ca22d1e8a346e45caeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484392de1623a3a409dcae746cd5adc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a484392de1623a3a409dcae746cd5adc7">initNetworkColumns</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId)</td></tr>
<tr class="memdesc:a484392de1623a3a409dcae746cd5adc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a network layer's column/node structure and sets detault values.  <a href="#a484392de1623a3a409dcae746cd5adc7">More...</a><br /></td></tr>
<tr class="separator:a484392de1623a3a409dcae746cd5adc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492680db02bd031d9ffdadd29f0b6ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a7492680db02bd031d9ffdadd29f0b6ae">initNetworkLayer</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerId, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:a7492680db02bd031d9ffdadd29f0b6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a network layer by creating the column/node structure and sets detault values.  <a href="#a7492680db02bd031d9ffdadd29f0b6ae">More...</a><br /></td></tr>
<tr class="separator:a7492680db02bd031d9ffdadd29f0b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d055950155f3889b1ec73ae07f7eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#ac1d055950155f3889b1ec73ae07f7eb7">initNetwork</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="separator:ac1d055950155f3889b1ec73ae07f7eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0aa6a4cb942e0b404e09871bed0834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#aaf0aa6a4cb942e0b404e09871bed0834">setNetworkDefaults</a> (<a class="el" href="struct_network.html">Network</a> *nn, int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs, <a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> netSize)</td></tr>
<tr class="memdesc:aaf0aa6a4cb942e0b404e09871bed0834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the network's default values for size, layerCount,.  <a href="#aaf0aa6a4cb942e0b404e09871bed0834">More...</a><br /></td></tr>
<tr class="separator:aaf0aa6a4cb942e0b404e09871bed0834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc5c41840ff31ff54eeedca9023501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_network.html">Network</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a4afc5c41840ff31ff54eeedca9023501">createNetwork</a> (int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:a4afc5c41840ff31ff54eeedca9023501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the neural network based on a given array of layer definitions.  <a href="#a4afc5c41840ff31ff54eeedca9023501">More...</a><br /></td></tr>
<tr class="separator:a4afc5c41840ff31ff54eeedca9023501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6da46d3b1bfb56a10bc72bd71f1140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#abd6da46d3b1bfb56a10bc72bd71f1140">isValidNetworkDefinition</a> (int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:abd6da46d3b1bfb56a10bc72bd71f1140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the network definition based on a number of rules and best practices.  <a href="#abd6da46d3b1bfb56a10bc72bd71f1140">More...</a><br /></td></tr>
<tr class="separator:abd6da46d3b1bfb56a10bc72bd71f1140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b18eda5fae1eb2fec1b0ca56f05dbf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#a2b18eda5fae1eb2fec1b0ca56f05dbf6">setLayerDefinitionDefaults</a> (int layerCount, <a class="el" href="struct_layer_definition.html">LayerDefinition</a> *layerDefs)</td></tr>
<tr class="memdesc:a2b18eda5fae1eb2fec1b0ca56f05dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array of a variable number of layer definitions.  <a href="#a2b18eda5fae1eb2fec1b0ca56f05dbf6">More...</a><br /></td></tr>
<tr class="separator:a2b18eda5fae1eb2fec1b0ca56f05dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fe916125b608a79e7cf14cdb443c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mlnn_8c.html#af5fe916125b608a79e7cf14cdb443c25">setLayerDefinitions</a> (int layerCount,...)</td></tr>
<tr class="memdesc:af5fe916125b608a79e7cf14cdb443c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an array of a variable number of layer definitions.  <a href="#af5fe916125b608a79e7cf14cdb443c25">More...</a><br /></td></tr>
<tr class="separator:af5fe916125b608a79e7cf14cdb443c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Neural network functionality for a multi-layer, convolutional neural network. </p>
<dl class="section author"><dt>Author</dt><dd>Matt Lind </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 2015 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a494da497b677da05f7a302152fafd248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUT_OF_RANGE&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5e8e1d7b9e01161fbe06cc9f08aafca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void activateNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a56b0419d049f390f332329193f952b41">ActFctType</a>&#160;</td>
          <td class="paramname"><em>actType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an activiation function to a specified node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the node that is to be "activated" </td></tr>
    <tr><td class="paramname">actType</td><td>The type of activation function to be applied (SIGMOID/TANH/RELU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e0365337d14604a9997ef50adf40d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void backPropagateLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Back propagates network error to hidden layer. </p>
<p>Backpropagating a layer means looping through all its nodes' connections, and update the errorSum attached to the TARGET node (=previous layer) of each connection i.e. when "backpropagating" layer x, then the errorSum of the nodes of layer x-1 are calculated </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">layerId</td><td>The id of the layer that is to be back propagated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf50ce1c1d143d737a0e7e9fa7faac4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void backPropagateNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetClassification</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backpropagates the output nodes' errors from output layer backwards to first layer. </p>
<p>Back propagates network error from output layer to hidden layer.</p>
<p>The network's backpropagation proceeds in 2 steps:</p>
<ol type="1">
<li>CALCULATE OUTPUT NODES' ERRORS a. Calculate the errorsums in all output cells based on the targetClassification</li>
<li>BACKPROPAGATE EACH LAYER a. Update the nodes weights based on actual output and accumulated errorsum b. Calculate the errorsums in all TARGET cells based on errorsum in this layer (calculated in 3)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">targetClassification</td><td>The correct/desired classification (=label) of this recognition/image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83887b62ebfd3e1a850cf1a4af109cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void backPropagateOutputLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetClassification</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the error (difference of desired classification vs actual node output) of each output node and back propagates the error in the output layer to the previous layer. </p>
<p>The error is calculated based on the given target classification (= image label) and is stored in each output node so that it can be backpropagated later </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">targetClassification</td><td>The correct/desired classification (=label) of this recognition/image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8067b0a998c5d56f43059af6ad93651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calcFilterColumnIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>srcLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcColId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>tgtLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vector.html">Vector</a> *&#160;</td>
          <td class="paramname"><em>filterColIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of FILTER-many column ids representing a moving x*y kernel window in the target layer. </p>
<p>The node ids are calculated relative to the nodeId of the parent/calling feature map. The size of the moving filter/frame is defined in the parent/calling layer's filter width/height values. The size of the parent/calling feature map is bigger than the target feature map, i.e. each x'th (2nd) node, horizontally as well as vertically, is skipped. If a filter's target node would be located outside of the target feature map, -1 is assigned as an id. Later all nodes pointing to a -1 node get assigned a weight pointer to the network's "nn-&gt;nullWeight", so that they are still dereferencable. (Because NULL pointers would cause an exception/termination.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcLayer</td><td>A pointer to the convolutional layer (SOURCE) that creates connections to its previous layer </td></tr>
    <tr><td class="paramname">srcColId</td><td>The id of the column in the convolutional (SOURCE) layer that creates the connections </td></tr>
    <tr><td class="paramname">tgtLayer</td><td>A pointer to the TARGET layer to which the convolutional/source layer connects to </td></tr>
    <tr><td class="paramname">filterColIds</td><td>A pointer to the vector which will return the list of filter ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa057b6a28d523972c7a38b98302cad2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calcNetworkLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the output values of all nodes of a given layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Pointer to the layer whose nodes are to be activated/calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a306d895940d6ff9c2f4a0403ff2ccee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calcNodeError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>thisNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total error of a node by adding up all the partial errors from the following layer. </p>
<p>To speed up back propagation the partial errors are referenced via the node's forward connections </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisNode</td><td>A pointer to the node whose (to be back propagated) error is to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a766a4329ca60f56b46872ac1ef641ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calcNodeOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the output value of a specified node. </p>
<p>Calculates the vector product of a node's weights with the connections' target nodes' outputs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the node whose output is to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3d9688a88ad92eb0eda60f0c57f0db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calcStride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tgtWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the stride (number of nodes/columns that are skipped) in a convolutional kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgtWidth</td><td>Number of columns on the x-axis (horizontally) in the TARGET (=previous) layer </td></tr>
    <tr><td class="paramname">filter</td><td>Number of columns/nodes on the x-axis in a filter window (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>ASSSUMES WIDTH=HEIGHT!!) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcWidth</td><td>Number of columns on the x-axis (horizontally) in the SOURCE (=this) layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf1c0bc7a8f6fa060d9601f3eafc00de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vector.html">Vector</a>* createFilterColumnIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>thisLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns an array of FILTER-many column ids representing a moving x*y kernel window. </p>
<p>The actual calculation of the target column ids takes place in a subfunction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisLayer</td><td>A pointer to the convolutional layer (SOURCE) that creates connections to its previous layer </td></tr>
    <tr><td class="paramname">columnId</td><td>The id of the column in the source layer </td></tr>
    <tr><td class="paramname">prevLayer</td><td>A pointer to the PREVIOUS=TARGET layer to which the convolutional/source layer connects to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4afc5c41840ff31ff54eeedca9023501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_network.html">Network</a>* createNetwork </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the neural network based on a given array of layer definitions. </p>
<p>Creates a reserved memory block for this network based on the given layer definitions, and then initializes this memory with the respective layer/node/connection/weights structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>The number of layer definitions inside the layer-definition-array (2nd param) </td></tr>
    <tr><td class="paramname">layerDefs</td><td>A pointer to an array of layer definitions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3aab148c4bc1bc374291e64edbf1e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void feedForwardNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feeds forward (=calculating a node's output value and applying an activation function) layer by layer. </p>
<p>Feeds input layer values forward to hidden to output layer (calculation and activation fct)</p>
<p>Feeds forward from 2nd=#1 layer (i.e. skips input layer) to output layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the NN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a498c47a729c9e9a8e3996dc4cc01a257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void feedInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vector.html">Vector</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feeds some <a class="el" href="struct_vector.html">Vector</a> data into the INPUT layer of the network. </p>
<p>Feeds some <a class="el" href="struct_vector.html">Vector</a> data into the INPUT layer of the NN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">v</td><td>A pointer to the vector holding the input values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cbce462165eb8f47736c942765b3f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getColumnCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of columns in a layer (based on a give layer definition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to the layer definition for this layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac71a3e5c9908ba6d1a5d4cbb9a1da62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a>* getColumnNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_column.html">Column</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a specific node defined by its id from a given layer. </p>
<p>The node is retrieved by moving a pointer from this layer's 1st node forward by id*nodeSize (it is NOT possible to retrieve a node simply via an array because the actual size of a node depends on its number of connections) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>A pointer to the column where this node is located in </td></tr>
    <tr><td class="paramname">nodeId</td><td>The id of the node that is to be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6d6765283218ff82291d62935de17e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getColumnSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory (byte) size of a column based on a given layer definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c96db47579c05ca68eb580627f075cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> getDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a>&#160;</td>
          <td class="paramname"><em>outVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a56b0419d049f390f332329193f952b41">ActFctType</a>&#160;</td>
          <td class="paramname"><em>actType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of applying the given outputValue to the derivate of the activation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outVal</td><td>Output value that is to be back propagated </td></tr>
    <tr><td class="paramname">actType</td><td>The type of activation function that was applied during feed forward (SIGMOID/TANH/RELU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17a5338950c6985c0232440b529b05d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_column.html">Column</a>* getLayerColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a specific column defined by its id. </p>
<p>The column is retrieved by moving a pointer from the layer's 1st column forward (it is NOT possible to retrieve a column simply via an array because the actual size of each column depends on its number/sizes of nodes and thus is variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>A pointer to the layer from which to get the column </td></tr>
    <tr><td class="paramname">columnId</td><td>The id of the column that is to be retrieved/accessed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa794952814e98d37851b303e17c60ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLayerColumnCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of columns in a layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>Pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea9b074d771e7fc536af05f468c277c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLayerNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in a layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>Pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a793c21439d5b143c92b5aaa4ffc3f947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getLayerSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory (byte) size of a specific layer based on a given layer definition. </p>
<p>Each layer's memory size may be different due to a different number of nodes and connections For FEED FORWARD (e.g. OUTPUT) layers, full connectivity is assumed (i.e. each node links to ALL nodes in the previous layer) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c35bcf728651f05c3461d89a04144d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getLayerWeightBlockSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory (byte) size of the weights block for a specific layer. </p>
<p>Each layer's number of weights may be different due to a different number of connections For FEED FORWARD (HIDDEN and OUTPUT) layers, full connectivity is assumed, CONV layers e.g. share weights. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec138a1288ed75be554026e0dd5fbf4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLayerWeightCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of weights for a layer (based on a given layer definition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to the layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2594878532b97d3e8581dcde4da0ffdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNetworkClassification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the network's classification of the input image by choosing the node with the hightest output. </p>
<p>Returns the network's classification using the ID of teh node with the hightest output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c60aaa5ced3776b44d804530b96d684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_layer.html">Layer</a>* getNetworkLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a specific layer defined by its id from the network. </p>
<p>The layer is retrieved by moving a pointer from the network's 1st layer forward by layerId*layerSize (it is NOT possible to retrieve a layer simply via an array because the actual size of EACH layer depends on its number/sizes of nodes) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the NN </td></tr>
    <tr><td class="paramname">layerId</td><td>The id of the layer that is to be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4db7db0fe79bde079c77cdf70d66047d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a>* getNetworkNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a specific node defined by its layer, column and node id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>A pointer to a network layer </td></tr>
    <tr><td class="paramname">columnId</td><td>The id of the column inside this layer </td></tr>
    <tr><td class="paramname">nodeId</td><td>The id of the node inside this column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22291d5113dee2df10981d3ac398fda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getNetworkSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory size of the network based on an array of layer definitions and weightBlockSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>Number of defined layers for this network </td></tr>
    <tr><td class="paramname">layerDefs</td><td>Array of layer definitions</td></tr>
  </table>
  </dd>
</dl>
<p>number of columns = width * height number of nodes per column = depth number of nodes = width * height * depth number of connections = filter * depth of previous layer * number of nodes number of weights = filter * depth of previous layer * depth of this layer </p>

</div>
</div>
<a class="anchor" id="a6f53bda77b00d02e5ee244a5bf80d571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getNetworkWeightBlockSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory size of the network's weights block based on a given array of layer definitions. </p>
<p>Each layer's number of weights may be different due to a different number of nodes &amp; connections The weight block is a block of memory that is located inside the network object, AFTER the layers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>The number of layers in the network </td></tr>
    <tr><td class="paramname">layerDefs</td><td>A pointer to an array of layer definitions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ed146259dc505f7ef7b8f04881ee6fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNodeBackwardConnectionCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of backward connections of a NODE (not of a layer) </p>
<p>For FEED FORWARD (HIDDEN and OUTPUT) layers, full connectivity is assumed (each node links to ALL nodes in the previous layer) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>Pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b86acbe777bfb0967fa143cd4409d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNodeForwardConnectionCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of forward connections of a NODE (not of a layer) </p>
<dl class="section attention"><dt>Attention</dt><dd>The number of FORWARD connections in one layer is NOT the same as the number of BACKWARD connections in the following layer!! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>A pointer to the layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08566a3881abbe4047eb9329b08355a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a> getNodeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory (byte) size of a node based on a given layer definition. </p>
<p>Each layer's nodes' memory size may be different due to a different number of connections For FEED FORWARD (HIDDEN and OUTPUT) layers, full connectivity is assumed (each node links to ALL nodes in the previous layer) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerDef</td><td>Pointer to a layer definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1d055950155f3889b1ec73ae07f7eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acfb20b4438bf1c9594706fb000753b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkBackwardConnectionsConvNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td>
          <td class="paramname"><em>srcLayerWeightPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>targetLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vector.html">Vector</a> *&#160;</td>
          <td class="paramname"><em>filterColIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td>
          <td class="paramname"><em>nullWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a single convolutional node by setting its connections weights pointers. </p>
<p>Each convolutional node has connections to a filter/kernel window of nodes in the previous layer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to the convolutional node whose connections are to be set/initialized </td></tr>
    <tr><td class="paramname">srcLevel</td><td>The node's level inside the column. Needed to calculate the position of the respective weight. </td></tr>
    <tr><td class="paramname">srcLayerWeightPtr</td><td>A pointer to the weight block of this (=convolutional node's) layer </td></tr>
    <tr><td class="paramname">targetLayer</td><td>A pointer to the target layer to which this convolutional node shall connect to </td></tr>
    <tr><td class="paramname">filterColIds</td><td>A vector of indeces/positions of the target columns/nodes that this node connects to </td></tr>
    <tr><td class="paramname">nullWeight</td><td>A pointer to a weight that is used (1) to initialize or (2) to link "dead" connections</td></tr>
  </table>
  </dd>
</dl>
<p>The following describes the logic/algorithm for calculating the weights' position</p>
<p>use WEIGHT MATRIX (of size filter * filter) for LEVEL 1 establish connections from source node to all nodes on LEVEL 1 inside the TARGET FILTER using WM1 use WEIGHT MATRIX of LEVEL 2 establish connections from source node to all nodes on LEVEL 2 inside the TARGET FILTER using WM2 same for all levels of TARGET LAYER</p>
<p>move source node to next node (= next node/level in SAME COLUMN!)</p>
<p>do same as above, again from LEVEL1-n using WM1-n</p>
<p>weights pointer position = (srcLevel * tgtDepth * filterSize) + (tgtLevel * filterSizer) + filterColId</p>
<p>move the filter using the SAME WEIGHT MATRIX across the target layer then move 1 level down in the TARGET layer </p>

</div>
</div>
<a class="anchor" id="a53fd605a32d4c375d73f72d0f23584b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkBackwardConnectionsFCNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>thisNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td>
          <td class="paramname"><em>nodeWeightPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a node of a normal, fully connected node. </p>
<p>Creates connections with pointers towards all nodes of the previous layer (=fully connected) </p><dl class="section attention"><dt>Attention</dt><dd>The node's bias weight is not initialized here but together with the weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisNode</td><td>A pointer to the node whose connections are to be added/initialized </td></tr>
    <tr><td class="paramname">prevLayer</td><td>A pointer to the PREVIOUS layer which this node will connect to </td></tr>
    <tr><td class="paramname">nodeWeightPtr</td><td>A pointer to the memory block that is to store the weights of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a484392de1623a3a409dcae746cd5adc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkColumns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a network layer's column/node structure and sets detault values. </p>
<p>A column is a vector of nodes. The number of nodes in a colum is defined as the "DEPTH" (or number of feature maps) For non-convolutional layers the DEPTH (i.e. number of nodes in a column) is 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer the network </td></tr>
    <tr><td class="paramname">layerId</td><td>The id of the layer whose column are to be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af94a8a48b0b4385887b3e0cf2d5eaa89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkForwardConnections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c4b1174c9c2a9c2deb35870af493210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkForwardConnectionsAnyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>thisNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>nextLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7492680db02bd031d9ffdadd29f0b6ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a network layer by creating the column/node structure and sets detault values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">layerId</td><td>The id of the layer which is to be initialized </td></tr>
    <tr><td class="paramname">layerDefs</td><td>Pointer to an array of layer definitions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4f85c53c92f9ca22d1e8a346e45caeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the nodes in a given network column. </p>
<p>Creates the column/node structure inside the network's respective memory block. Connections will be initialized with a NULL pointer and a default -&gt;nullWeight pointer (for null weights I don't use NULL to avoid exceptions if it is (mistakenly?) dereferenced) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the network </td></tr>
    <tr><td class="paramname">layerId</td><td>The index of the layer whose column=nodes are to be initialized </td></tr>
    <tr><td class="paramname">columnId</td><td>The index of the column whose nodes are to be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a26cfa36bff4cdbcd279508a39b44b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initNetworkWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd6da46d3b1bfb56a10bc72bd71f1140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidNetworkDefinition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the network definition based on a number of rules and best practices. </p>
<p>Checks whether the provided layer definitions define a proper/feasible a neural network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>Number of defined layers for this network </td></tr>
    <tr><td class="paramname">layerDefs</td><td>A pointer to an array of layer definitions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b18eda5fae1eb2fec1b0ca56f05dbf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLayerDefinitionDefaults </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to an array of a variable number of layer definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>Number of layers of the network </td></tr>
    <tr><td class="paramname">layerDefs</td><td>Variabe number of layer definition objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5fe916125b608a79e7cf14cdb443c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_layer_definition.html">LayerDefinition</a>* setLayerDefinitions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to an array of a variable number of layer definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerCount</td><td>Number of layers of the network </td></tr>
    <tr><td class="paramname">...</td><td>Variabe number of layer definition objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf0aa6a4cb942e0b404e09871bed0834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setNetworkDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network.html">Network</a> *&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_layer_definition.html">LayerDefinition</a> *&#160;</td>
          <td class="paramname"><em>layerDefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a7a4b57eb083e961719b18441711d8ee5">ByteSize</a>&#160;</td>
          <td class="paramname"><em>netSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the network's default values for size, layerCount,. </p>
<p>Theses values are needed to "navigate" inside the network object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn</td><td>A pointer to the neural network </td></tr>
    <tr><td class="paramname">layerCount</td><td>The number of layers of this network </td></tr>
    <tr><td class="paramname">layerDefs</td><td>A pointer to an array of the layer definitions for this network </td></tr>
    <tr><td class="paramname">netSize</td><td>Total memory size of the network </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12f1992d0aaec1e32c16f5100a7ca0c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setNetworkNodeDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_layer.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>thisLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_column.html">Column</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mlnn_8h.html#a5b53e5716aeadbb040a52c9c8c124c74">Weight</a> *&#160;</td>
          <td class="paramname"><em>nullWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets default values for a node during its initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisLayer</td><td>A pointer to the layer in which the node is located </td></tr>
    <tr><td class="paramname">column</td><td>A pointer to the column in which the node is located </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the node whose values are to be (re)set </td></tr>
    <tr><td class="paramname">nullWeight</td><td>A pointer to the network's null weight </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4140a0839a2ef1ba88b90ba340b41090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateNodeWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>updateNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>learningRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a node's weights based on given learning rate. </p>
<p>The accumulated error (difference between desired output and actual output) of this node must have been calculated before and attached to the node (= -&gt;errorSum) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateNode</td><td>A pointer to the node whose weights are to be updated </td></tr>
    <tr><td class="paramname">learningRate</td><td>The factor with which errors are applied to weights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
